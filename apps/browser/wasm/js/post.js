var i=(Z,Q)=>()=>(Q||Z((Q={exports:{}}).exports,Q),Q.exports);var o=i((j1)=>{function r(Z){var Q=Z.length;if(Q%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var Y=Z.indexOf("=");if(Y===-1)Y=Q;var $=Y===Q?0:4-Y%4;return[Y,$]}function w1(Z){var Q=r(Z),Y=Q[0],$=Q[1];return(Y+$)*3/4-$}function T1(Z,Q,Y){return(Q+Y)*3/4-Y}function H1(Z){var Q,Y=r(Z),$=Y[0],J=Y[1],D=new _1(T1(Z,$,J)),F=0,q=J>0?$-4:$,K;for(K=0;K<q;K+=4)Q=V[Z.charCodeAt(K)]<<18|V[Z.charCodeAt(K+1)]<<12|V[Z.charCodeAt(K+2)]<<6|V[Z.charCodeAt(K+3)],D[F++]=Q>>16&255,D[F++]=Q>>8&255,D[F++]=Q&255;if(J===2)Q=V[Z.charCodeAt(K)]<<2|V[Z.charCodeAt(K+1)]>>4,D[F++]=Q&255;if(J===1)Q=V[Z.charCodeAt(K)]<<10|V[Z.charCodeAt(K+1)]<<4|V[Z.charCodeAt(K+2)]>>2,D[F++]=Q>>8&255,D[F++]=Q&255;return D}function N1(Z){return w[Z>>18&63]+w[Z>>12&63]+w[Z>>6&63]+w[Z&63]}function C1(Z,Q,Y){var $,J=[];for(var D=Q;D<Y;D+=3)$=(Z[D]<<16&16711680)+(Z[D+1]<<8&65280)+(Z[D+2]&255),J.push(N1($));return J.join("")}function z1(Z){var Q,Y=Z.length,$=Y%3,J=[],D=16383;for(var F=0,q=Y-$;F<q;F+=D)J.push(C1(Z,F,F+D>q?q:F+D));if($===1)Q=Z[Y-1],J.push(w[Q>>2]+w[Q<<4&63]+"==");else if($===2)Q=(Z[Y-2]<<8)+Z[Y-1],J.push(w[Q>>10]+w[Q>>4&63]+w[Q<<2&63]+"=");return J.join("")}j1.byteLength=w1;j1.toByteArray=H1;j1.fromByteArray=z1;var w=[],V=[],_1=typeof Uint8Array!=="undefined"?Uint8Array:Array,p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(z=0,a=p.length;z<a;++z)w[z]=p[z],V[p.charCodeAt(z)]=z;var z,a;V["-".charCodeAt(0)]=62;V["_".charCodeAt(0)]=63});var n=i((I1)=>{/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */I1.read=function(Z,Q,Y,$,J){var D,F,q=J*8-$-1,K=(1<<q)-1,R=K>>1,U=-7,W=Y?J-1:0,C=Y?-1:1,_=Z[Q+W];W+=C,D=_&(1<<-U)-1,_>>=-U,U+=q;for(;U>0;D=D*256+Z[Q+W],W+=C,U-=8);F=D&(1<<-U)-1,D>>=-U,U+=$;for(;U>0;F=F*256+Z[Q+W],W+=C,U-=8);if(D===0)D=1-R;else if(D===K)return F?NaN:(_?-1:1)*(1/0);else F=F+Math.pow(2,$),D=D-R;return(_?-1:1)*F*Math.pow(2,D-$)};I1.write=function(Z,Q,Y,$,J,D){var F,q,K,R=D*8-J-1,U=(1<<R)-1,W=U>>1,C=J===23?Math.pow(2,-24)-Math.pow(2,-77):0,_=$?0:D-1,O=$?1:-1,V1=Q<0||Q===0&&1/Q<0?1:0;if(Q=Math.abs(Q),isNaN(Q)||Q===1/0)q=isNaN(Q)?1:0,F=U;else{if(F=Math.floor(Math.log(Q)/Math.LN2),Q*(K=Math.pow(2,-F))<1)F--,K*=2;if(F+W>=1)Q+=C/K;else Q+=C*Math.pow(2,1-W);if(Q*K>=2)F++,K/=2;if(F+W>=U)q=0,F=U;else if(F+W>=1)q=(Q*K-1)*Math.pow(2,J),F=F+W;else q=Q*Math.pow(2,W-1)*Math.pow(2,J),F=0}for(;J>=8;Z[Y+_]=q&255,_+=O,q/=256,J-=8);F=F<<J|q,R+=J;for(;R>0;Z[Y+_]=F&255,_+=O,F/=256,R-=8);Z[Y+_-O]|=V1*128}});function A1(){try{const Z=new Uint8Array(1),Q={foo:function(){return 42}};return Object.setPrototypeOf(Q,Uint8Array.prototype),Object.setPrototypeOf(Z,Q),Z.foo()===42}catch(Z){return!1}}function H(Z){if(Z>L)throw new RangeError('The value "'+Z+'" is invalid for option "size"');const Q=new Uint8Array(Z);return Object.setPrototypeOf(Q,M.prototype),Q}function M(Z,Q,Y){if(typeof Z==="number"){if(typeof Q==="string")throw new TypeError('The "string" argument must be of type string. Received type number');return c(Z)}return Q1(Z,Q,Y)}function Q1(Z,Q,Y){if(typeof Z==="string")return p1(Z,Q);if(ArrayBuffer.isView(Z))return m1(Z);if(Z==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof Z);if(T(Z,ArrayBuffer)||Z&&T(Z.buffer,ArrayBuffer))return y(Z,Q,Y);if(typeof SharedArrayBuffer!=="undefined"&&(T(Z,SharedArrayBuffer)||Z&&T(Z.buffer,SharedArrayBuffer)))return y(Z,Q,Y);if(typeof Z==="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const $=Z.valueOf&&Z.valueOf();if($!=null&&$!==Z)return M.from($,Q,Y);const J=L1(Z);if(J)return J;if(typeof Symbol!=="undefined"&&Symbol.toPrimitive!=null&&typeof Z[Symbol.toPrimitive]==="function")return M.from(Z[Symbol.toPrimitive]("string"),Q,Y);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof Z)}function Y1(Z){if(typeof Z!=="number")throw new TypeError('"size" argument must be of type number');else if(Z<0)throw new RangeError('The value "'+Z+'" is invalid for option "size"')}function O1(Z,Q,Y){if(Y1(Z),Z<=0)return H(Z);if(Q!==void 0)return typeof Y==="string"?H(Z).fill(Q,Y):H(Z).fill(Q);return H(Z)}function c(Z){return Y1(Z),H(Z<0?0:v(Z)|0)}function p1(Z,Q){if(typeof Q!=="string"||Q==="")Q="utf8";if(!M.isEncoding(Q))throw new TypeError("Unknown encoding: "+Q);const Y=Z1(Z,Q)|0;let $=H(Y);const J=$.write(Z,Q);if(J!==Y)$=$.slice(0,J);return $}function B(Z){const Q=Z.length<0?0:v(Z.length)|0,Y=H(Q);for(let $=0;$<Q;$+=1)Y[$]=Z[$]&255;return Y}function m1(Z){if(T(Z,Uint8Array)){const Q=new Uint8Array(Z);return y(Q.buffer,Q.byteOffset,Q.byteLength)}return B(Z)}function y(Z,Q,Y){if(Q<0||Z.byteLength<Q)throw new RangeError('"offset" is outside of buffer bounds');if(Z.byteLength<Q+(Y||0))throw new RangeError('"length" is outside of buffer bounds');let $;if(Q===void 0&&Y===void 0)$=new Uint8Array(Z);else if(Y===void 0)$=new Uint8Array(Z,Q);else $=new Uint8Array(Z,Q,Y);return Object.setPrototypeOf($,M.prototype),$}function L1(Z){if(M.isBuffer(Z)){const Q=v(Z.length)|0,Y=H(Q);if(Y.length===0)return Y;return Z.copy(Y,0,0,Q),Y}if(Z.length!==void 0){if(typeof Z.length!=="number"||d(Z.length))return H(0);return B(Z)}if(Z.type==="Buffer"&&Array.isArray(Z.data))return B(Z.data)}function v(Z){if(Z>=L)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+L.toString(16)+" bytes");return Z|0}function Z1(Z,Q){if(M.isBuffer(Z))return Z.length;if(ArrayBuffer.isView(Z)||T(Z,ArrayBuffer))return Z.byteLength;if(typeof Z!=="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof Z);const Y=Z.length,$=arguments.length>2&&arguments[2]===!0;if(!$&&Y===0)return 0;let J=!1;for(;;)switch(Q){case"ascii":case"latin1":case"binary":return Y;case"utf8":case"utf-8":return h(Z).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Y*2;case"hex":return Y>>>1;case"base64":return W1(Z).length;default:if(J)return $?-1:h(Z).length;Q=(""+Q).toLowerCase(),J=!0}}function B1(Z,Q,Y){let $=!1;if(Q===void 0||Q<0)Q=0;if(Q>this.length)return"";if(Y===void 0||Y>this.length)Y=this.length;if(Y<=0)return"";if(Y>>>=0,Q>>>=0,Y<=Q)return"";if(!Z)Z="utf8";while(!0)switch(Z){case"hex":return i1(this,Q,Y);case"utf8":case"utf-8":return J1(this,Q,Y);case"ascii":return l1(this,Q,Y);case"latin1":case"binary":return u1(this,Q,Y);case"base64":return d1(this,Q,Y);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return a1(this,Q,Y);default:if($)throw new TypeError("Unknown encoding: "+Z);Z=(Z+"").toLowerCase(),$=!0}}function j(Z,Q,Y){const $=Z[Q];Z[Q]=Z[Y],Z[Y]=$}function $1(Z,Q,Y,$,J){if(Z.length===0)return-1;if(typeof Y==="string")$=Y,Y=0;else if(Y>2147483647)Y=2147483647;else if(Y<-2147483648)Y=-2147483648;if(Y=+Y,d(Y))Y=J?0:Z.length-1;if(Y<0)Y=Z.length+Y;if(Y>=Z.length)if(J)return-1;else Y=Z.length-1;else if(Y<0)if(J)Y=0;else return-1;if(typeof Q==="string")Q=M.from(Q,$);if(M.isBuffer(Q)){if(Q.length===0)return-1;return f(Z,Q,Y,$,J)}else if(typeof Q==="number"){if(Q=Q&255,typeof Uint8Array.prototype.indexOf==="function")if(J)return Uint8Array.prototype.indexOf.call(Z,Q,Y);else return Uint8Array.prototype.lastIndexOf.call(Z,Q,Y);return f(Z,[Q],Y,$,J)}throw new TypeError("val must be string, number or Buffer")}function f(Z,Q,Y,$,J){let D=1,F=Z.length,q=Q.length;if($!==void 0){if($=String($).toLowerCase(),$==="ucs2"||$==="ucs-2"||$==="utf16le"||$==="utf-16le"){if(Z.length<2||Q.length<2)return-1;D=2,F/=2,q/=2,Y/=2}}function K(U,W){if(D===1)return U[W];else return U.readUInt16BE(W*D)}let R;if(J){let U=-1;for(R=Y;R<F;R++)if(K(Z,R)===K(Q,U===-1?0:R-U)){if(U===-1)U=R;if(R-U+1===q)return U*D}else{if(U!==-1)R-=R-U;U=-1}}else{if(Y+q>F)Y=F-q;for(R=Y;R>=0;R--){let U=!0;for(let W=0;W<q;W++)if(K(Z,R+W)!==K(Q,W)){U=!1;break}if(U)return R}}return-1}function y1(Z,Q,Y,$){Y=Number(Y)||0;const J=Z.length-Y;if(!$)$=J;else if($=Number($),$>J)$=J;const D=Q.length;if($>D/2)$=D/2;let F;for(F=0;F<$;++F){const q=parseInt(Q.substr(F*2,2),16);if(d(q))return F;Z[Y+F]=q}return F}function h1(Z,Q,Y,$){return S(h(Q,Z.length-Y),Z,Y,$)}function c1(Z,Q,Y,$){return S(s1(Q),Z,Y,$)}function v1(Z,Q,Y,$){return S(W1(Q),Z,Y,$)}function b1(Z,Q,Y,$){return S(f1(Q,Z.length-Y),Z,Y,$)}function d1(Z,Q,Y){if(Q===0&&Y===Z.length)return m.fromByteArray(Z);else return m.fromByteArray(Z.slice(Q,Y))}function J1(Z,Q,Y){Y=Math.min(Z.length,Y);const $=[];let J=Q;while(J<Y){const D=Z[J];let F=null,q=D>239?4:D>223?3:D>191?2:1;if(J+q<=Y){let K,R,U,W;switch(q){case 1:if(D<128)F=D;break;case 2:if(K=Z[J+1],(K&192)===128){if(W=(D&31)<<6|K&63,W>127)F=W}break;case 3:if(K=Z[J+1],R=Z[J+2],(K&192)===128&&(R&192)===128){if(W=(D&15)<<12|(K&63)<<6|R&63,W>2047&&(W<55296||W>57343))F=W}break;case 4:if(K=Z[J+1],R=Z[J+2],U=Z[J+3],(K&192)===128&&(R&192)===128&&(U&192)===128){if(W=(D&15)<<18|(K&63)<<12|(R&63)<<6|U&63,W>65535&&W<1114112)F=W}}}if(F===null)F=65533,q=1;else if(F>65535)F-=65536,$.push(F>>>10&1023|55296),F=56320|F&1023;$.push(F),J+=q}return g1($)}function g1(Z){const Q=Z.length;if(Q<=t)return String.fromCharCode.apply(String,Z);let Y="",$=0;while($<Q)Y+=String.fromCharCode.apply(String,Z.slice($,$+=t));return Y}function l1(Z,Q,Y){let $="";Y=Math.min(Z.length,Y);for(let J=Q;J<Y;++J)$+=String.fromCharCode(Z[J]&127);return $}function u1(Z,Q,Y){let $="";Y=Math.min(Z.length,Y);for(let J=Q;J<Y;++J)$+=String.fromCharCode(Z[J]);return $}function i1(Z,Q,Y){const $=Z.length;if(!Q||Q<0)Q=0;if(!Y||Y<0||Y>$)Y=$;let J="";for(let D=Q;D<Y;++D)J+=t1[Z[D]];return J}function a1(Z,Q,Y){const $=Z.slice(Q,Y);let J="";for(let D=0;D<$.length-1;D+=2)J+=String.fromCharCode($[D]+$[D+1]*256);return J}function X(Z,Q,Y){if(Z%1!==0||Z<0)throw new RangeError("offset is not uint");if(Z+Q>Y)throw new RangeError("Trying to access beyond buffer length")}function G(Z,Q,Y,$,J,D){if(!M.isBuffer(Z))throw new TypeError('"buffer" argument must be a Buffer instance');if(Q>J||Q<D)throw new RangeError('"value" argument is out of bounds');if(Y+$>Z.length)throw new RangeError("Index out of range")}function D1(Z,Q,Y,$,J){U1(Q,$,J,Z,Y,7);let D=Number(Q&BigInt(4294967295));Z[Y++]=D,D=D>>8,Z[Y++]=D,D=D>>8,Z[Y++]=D,D=D>>8,Z[Y++]=D;let F=Number(Q>>BigInt(32)&BigInt(4294967295));return Z[Y++]=F,F=F>>8,Z[Y++]=F,F=F>>8,Z[Y++]=F,F=F>>8,Z[Y++]=F,Y}function F1(Z,Q,Y,$,J){U1(Q,$,J,Z,Y,7);let D=Number(Q&BigInt(4294967295));Z[Y+7]=D,D=D>>8,Z[Y+6]=D,D=D>>8,Z[Y+5]=D,D=D>>8,Z[Y+4]=D;let F=Number(Q>>BigInt(32)&BigInt(4294967295));return Z[Y+3]=F,F=F>>8,Z[Y+2]=F,F=F>>8,Z[Y+1]=F,F=F>>8,Z[Y]=F,Y+8}function M1(Z,Q,Y,$,J,D){if(Y+$>Z.length)throw new RangeError("Index out of range");if(Y<0)throw new RangeError("Index out of range")}function q1(Z,Q,Y,$,J){if(Q=+Q,Y=Y>>>0,!J)M1(Z,Q,Y,4,340282346638528860000000000000000000000,-340282346638528860000000000000000000000);return x.write(Z,Q,Y,$,23,4),Y+4}function K1(Z,Q,Y,$,J){if(Q=+Q,Y=Y>>>0,!J)M1(Z,Q,Y,8,179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,-179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);return x.write(Z,Q,Y,$,52,8),Y+8}function b(Z,Q,Y){E[Z]=class $ extends Y{constructor(){super();Object.defineProperty(this,"message",{value:Q.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${Z}]`,this.stack,delete this.name}get code(){return Z}set code(J){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:J,writable:!0})}toString(){return`${this.name} [${Z}]: ${this.message}`}}}function e(Z){let Q="",Y=Z.length;const $=Z[0]==="-"?1:0;for(;Y>=$+4;Y-=3)Q=`_${Z.slice(Y-3,Y)}${Q}`;return`${Z.slice(0,Y)}${Q}`}function r1(Z,Q,Y){if(P(Q,"offset"),Z[Q]===void 0||Z[Q+Y]===void 0)I(Q,Z.length-(Y+1))}function U1(Z,Q,Y,$,J,D){if(Z>Y||Z<Q){const F=typeof Q==="bigint"?"n":"";let q;if(D>3)if(Q===0||Q===BigInt(0))q=`>= 0${F} and < 2${F} ** ${(D+1)*8}${F}`;else q=`>= -(2${F} ** ${(D+1)*8-1}${F}) and < 2 ** ${(D+1)*8-1}${F}`;else q=`>= ${Q}${F} and <= ${Y}${F}`;throw new E.ERR_OUT_OF_RANGE("value",q,Z)}r1($,J,D)}function P(Z,Q){if(typeof Z!=="number")throw new E.ERR_INVALID_ARG_TYPE(Q,"number",Z)}function I(Z,Q,Y){if(Math.floor(Z)!==Z)throw P(Z,Y),new E.ERR_OUT_OF_RANGE(Y||"offset","an integer",Z);if(Q<0)throw new E.ERR_BUFFER_OUT_OF_BOUNDS;throw new E.ERR_OUT_OF_RANGE(Y||"offset",`>= ${Y?1:0} and <= ${Q}`,Z)}function n1(Z){if(Z=Z.split("=")[0],Z=Z.trim().replace(o1,""),Z.length<2)return"";while(Z.length%4!==0)Z=Z+"=";return Z}function h(Z,Q){Q=Q||1/0;let Y;const $=Z.length;let J=null;const D=[];for(let F=0;F<$;++F){if(Y=Z.charCodeAt(F),Y>55295&&Y<57344){if(!J){if(Y>56319){if((Q-=3)>-1)D.push(239,191,189);continue}else if(F+1===$){if((Q-=3)>-1)D.push(239,191,189);continue}J=Y;continue}if(Y<56320){if((Q-=3)>-1)D.push(239,191,189);J=Y;continue}Y=(J-55296<<10|Y-56320)+65536}else if(J){if((Q-=3)>-1)D.push(239,191,189)}if(J=null,Y<128){if((Q-=1)<0)break;D.push(Y)}else if(Y<2048){if((Q-=2)<0)break;D.push(Y>>6|192,Y&63|128)}else if(Y<65536){if((Q-=3)<0)break;D.push(Y>>12|224,Y>>6&63|128,Y&63|128)}else if(Y<1114112){if((Q-=4)<0)break;D.push(Y>>18|240,Y>>12&63|128,Y>>6&63|128,Y&63|128)}else throw new Error("Invalid code point")}return D}function s1(Z){const Q=[];for(let Y=0;Y<Z.length;++Y)Q.push(Z.charCodeAt(Y)&255);return Q}function f1(Z,Q){let Y,$,J;const D=[];for(let F=0;F<Z.length;++F){if((Q-=2)<0)break;Y=Z.charCodeAt(F),$=Y>>8,J=Y%256,D.push(J),D.push($)}return D}function W1(Z){return m.toByteArray(n1(Z))}function S(Z,Q,Y,$){let J;for(J=0;J<$;++J){if(J+Y>=Q.length||J>=Z.length)break;Q[J+Y]=Z[J]}return J}function T(Z,Q){return Z instanceof Q||Z!=null&&Z.constructor!=null&&Z.constructor.name!=null&&Z.constructor.name===Q.name}function d(Z){return Z!==Z}function N(Z){return typeof BigInt==="undefined"?e1:Z}function e1(){throw new Error("BigInt not supported")}/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */var m=o(),x=n(),s=typeof Symbol==="function"&&typeof Symbol.for==="function"?Symbol.for("nodejs.util.inspect.custom"):null;var g=M;var R1=50;var L=2147483647;M.TYPED_ARRAY_SUPPORT=A1();if(!M.TYPED_ARRAY_SUPPORT&&typeof console!=="undefined"&&typeof console.error==="function")console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");Object.defineProperty(M.prototype,"parent",{enumerable:!0,get:function(){if(!M.isBuffer(this))return;return this.buffer}});Object.defineProperty(M.prototype,"offset",{enumerable:!0,get:function(){if(!M.isBuffer(this))return;return this.byteOffset}});M.poolSize=8192;M.from=function(Z,Q,Y){return Q1(Z,Q,Y)};Object.setPrototypeOf(M.prototype,Uint8Array.prototype);Object.setPrototypeOf(M,Uint8Array);M.alloc=function(Z,Q,Y){return O1(Z,Q,Y)};M.allocUnsafe=function(Z){return c(Z)};M.allocUnsafeSlow=function(Z){return c(Z)};M.isBuffer=function Z(Q){return Q!=null&&Q._isBuffer===!0&&Q!==M.prototype};M.compare=function Z(Q,Y){if(T(Q,Uint8Array))Q=M.from(Q,Q.offset,Q.byteLength);if(T(Y,Uint8Array))Y=M.from(Y,Y.offset,Y.byteLength);if(!M.isBuffer(Q)||!M.isBuffer(Y))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(Q===Y)return 0;let $=Q.length,J=Y.length;for(let D=0,F=Math.min($,J);D<F;++D)if(Q[D]!==Y[D]){$=Q[D],J=Y[D];break}if($<J)return-1;if(J<$)return 1;return 0};M.isEncoding=function Z(Q){switch(String(Q).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}};M.concat=function Z(Q,Y){if(!Array.isArray(Q))throw new TypeError('"list" argument must be an Array of Buffers');if(Q.length===0)return M.alloc(0);let $;if(Y===void 0){Y=0;for($=0;$<Q.length;++$)Y+=Q[$].length}const J=M.allocUnsafe(Y);let D=0;for($=0;$<Q.length;++$){let F=Q[$];if(T(F,Uint8Array))if(D+F.length>J.length){if(!M.isBuffer(F))F=M.from(F);F.copy(J,D)}else Uint8Array.prototype.set.call(J,F,D);else if(!M.isBuffer(F))throw new TypeError('"list" argument must be an Array of Buffers');else F.copy(J,D);D+=F.length}return J};M.byteLength=Z1;M.prototype._isBuffer=!0;M.prototype.swap16=function Z(){const Q=this.length;if(Q%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let Y=0;Y<Q;Y+=2)j(this,Y,Y+1);return this};M.prototype.swap32=function Z(){const Q=this.length;if(Q%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let Y=0;Y<Q;Y+=4)j(this,Y,Y+3),j(this,Y+1,Y+2);return this};M.prototype.swap64=function Z(){const Q=this.length;if(Q%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let Y=0;Y<Q;Y+=8)j(this,Y,Y+7),j(this,Y+1,Y+6),j(this,Y+2,Y+5),j(this,Y+3,Y+4);return this};M.prototype.toString=function Z(){const Q=this.length;if(Q===0)return"";if(arguments.length===0)return J1(this,0,Q);return B1.apply(this,arguments)};M.prototype.toLocaleString=M.prototype.toString;M.prototype.equals=function Z(Q){if(!M.isBuffer(Q))throw new TypeError("Argument must be a Buffer");if(this===Q)return!0;return M.compare(this,Q)===0};M.prototype.inspect=function Z(){let Q="";const Y=R1;if(Q=this.toString("hex",0,Y).replace(/(.{2})/g,"$1 ").trim(),this.length>Y)Q+=" ... ";return"<Buffer "+Q+">"};if(s)M.prototype[s]=M.prototype.inspect;M.prototype.compare=function Z(Q,Y,$,J,D){if(T(Q,Uint8Array))Q=M.from(Q,Q.offset,Q.byteLength);if(!M.isBuffer(Q))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof Q);if(Y===void 0)Y=0;if($===void 0)$=Q?Q.length:0;if(J===void 0)J=0;if(D===void 0)D=this.length;if(Y<0||$>Q.length||J<0||D>this.length)throw new RangeError("out of range index");if(J>=D&&Y>=$)return 0;if(J>=D)return-1;if(Y>=$)return 1;if(Y>>>=0,$>>>=0,J>>>=0,D>>>=0,this===Q)return 0;let F=D-J,q=$-Y;const K=Math.min(F,q),R=this.slice(J,D),U=Q.slice(Y,$);for(let W=0;W<K;++W)if(R[W]!==U[W]){F=R[W],q=U[W];break}if(F<q)return-1;if(q<F)return 1;return 0};M.prototype.includes=function Z(Q,Y,$){return this.indexOf(Q,Y,$)!==-1};M.prototype.indexOf=function Z(Q,Y,$){return $1(this,Q,Y,$,!0)};M.prototype.lastIndexOf=function Z(Q,Y,$){return $1(this,Q,Y,$,!1)};M.prototype.write=function Z(Q,Y,$,J){if(Y===void 0)J="utf8",$=this.length,Y=0;else if($===void 0&&typeof Y==="string")J=Y,$=this.length,Y=0;else if(isFinite(Y))if(Y=Y>>>0,isFinite($)){if($=$>>>0,J===void 0)J="utf8"}else J=$,$=void 0;else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const D=this.length-Y;if($===void 0||$>D)$=D;if(Q.length>0&&($<0||Y<0)||Y>this.length)throw new RangeError("Attempt to write outside buffer bounds");if(!J)J="utf8";let F=!1;for(;;)switch(J){case"hex":return y1(this,Q,Y,$);case"utf8":case"utf-8":return h1(this,Q,Y,$);case"ascii":case"latin1":case"binary":return c1(this,Q,Y,$);case"base64":return v1(this,Q,Y,$);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return b1(this,Q,Y,$);default:if(F)throw new TypeError("Unknown encoding: "+J);J=(""+J).toLowerCase(),F=!0}};M.prototype.toJSON=function Z(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var t=4096;M.prototype.slice=function Z(Q,Y){const $=this.length;if(Q=~~Q,Y=Y===void 0?$:~~Y,Q<0){if(Q+=$,Q<0)Q=0}else if(Q>$)Q=$;if(Y<0){if(Y+=$,Y<0)Y=0}else if(Y>$)Y=$;if(Y<Q)Y=Q;const J=this.subarray(Q,Y);return Object.setPrototypeOf(J,M.prototype),J};M.prototype.readUintLE=M.prototype.readUIntLE=function Z(Q,Y,$){if(Q=Q>>>0,Y=Y>>>0,!$)X(Q,Y,this.length);let J=this[Q],D=1,F=0;while(++F<Y&&(D*=256))J+=this[Q+F]*D;return J};M.prototype.readUintBE=M.prototype.readUIntBE=function Z(Q,Y,$){if(Q=Q>>>0,Y=Y>>>0,!$)X(Q,Y,this.length);let J=this[Q+--Y],D=1;while(Y>0&&(D*=256))J+=this[Q+--Y]*D;return J};M.prototype.readUint8=M.prototype.readUInt8=function Z(Q,Y){if(Q=Q>>>0,!Y)X(Q,1,this.length);return this[Q]};M.prototype.readUint16LE=M.prototype.readUInt16LE=function Z(Q,Y){if(Q=Q>>>0,!Y)X(Q,2,this.length);return this[Q]|this[Q+1]<<8};M.prototype.readUint16BE=M.prototype.readUInt16BE=function Z(Q,Y){if(Q=Q>>>0,!Y)X(Q,2,this.length);return this[Q]<<8|this[Q+1]};M.prototype.readUint32LE=M.prototype.readUInt32LE=function Z(Q,Y){if(Q=Q>>>0,!Y)X(Q,4,this.length);return(this[Q]|this[Q+1]<<8|this[Q+2]<<16)+this[Q+3]*16777216};M.prototype.readUint32BE=M.prototype.readUInt32BE=function Z(Q,Y){if(Q=Q>>>0,!Y)X(Q,4,this.length);return this[Q]*16777216+(this[Q+1]<<16|this[Q+2]<<8|this[Q+3])};M.prototype.readBigUInt64LE=N(function Z(Q){Q=Q>>>0,P(Q,"offset");const Y=this[Q],$=this[Q+7];if(Y===void 0||$===void 0)I(Q,this.length-8);const J=Y+this[++Q]*256+this[++Q]*65536+this[++Q]*16777216,D=this[++Q]+this[++Q]*256+this[++Q]*65536+$*16777216;return BigInt(J)+(BigInt(D)<<BigInt(32))});M.prototype.readBigUInt64BE=N(function Z(Q){Q=Q>>>0,P(Q,"offset");const Y=this[Q],$=this[Q+7];if(Y===void 0||$===void 0)I(Q,this.length-8);const J=Y*16777216+this[++Q]*65536+this[++Q]*256+this[++Q],D=this[++Q]*16777216+this[++Q]*65536+this[++Q]*256+$;return(BigInt(J)<<BigInt(32))+BigInt(D)});M.prototype.readIntLE=function Z(Q,Y,$){if(Q=Q>>>0,Y=Y>>>0,!$)X(Q,Y,this.length);let J=this[Q],D=1,F=0;while(++F<Y&&(D*=256))J+=this[Q+F]*D;if(D*=128,J>=D)J-=Math.pow(2,8*Y);return J};M.prototype.readIntBE=function Z(Q,Y,$){if(Q=Q>>>0,Y=Y>>>0,!$)X(Q,Y,this.length);let J=Y,D=1,F=this[Q+--J];while(J>0&&(D*=256))F+=this[Q+--J]*D;if(D*=128,F>=D)F-=Math.pow(2,8*Y);return F};M.prototype.readInt8=function Z(Q,Y){if(Q=Q>>>0,!Y)X(Q,1,this.length);if(!(this[Q]&128))return this[Q];return(255-this[Q]+1)*-1};M.prototype.readInt16LE=function Z(Q,Y){if(Q=Q>>>0,!Y)X(Q,2,this.length);const $=this[Q]|this[Q+1]<<8;return $&32768?$|4294901760:$};M.prototype.readInt16BE=function Z(Q,Y){if(Q=Q>>>0,!Y)X(Q,2,this.length);const $=this[Q+1]|this[Q]<<8;return $&32768?$|4294901760:$};M.prototype.readInt32LE=function Z(Q,Y){if(Q=Q>>>0,!Y)X(Q,4,this.length);return this[Q]|this[Q+1]<<8|this[Q+2]<<16|this[Q+3]<<24};M.prototype.readInt32BE=function Z(Q,Y){if(Q=Q>>>0,!Y)X(Q,4,this.length);return this[Q]<<24|this[Q+1]<<16|this[Q+2]<<8|this[Q+3]};M.prototype.readBigInt64LE=N(function Z(Q){Q=Q>>>0,P(Q,"offset");const Y=this[Q],$=this[Q+7];if(Y===void 0||$===void 0)I(Q,this.length-8);const J=this[Q+4]+this[Q+5]*256+this[Q+6]*65536+($<<24);return(BigInt(J)<<BigInt(32))+BigInt(Y+this[++Q]*256+this[++Q]*65536+this[++Q]*16777216)});M.prototype.readBigInt64BE=N(function Z(Q){Q=Q>>>0,P(Q,"offset");const Y=this[Q],$=this[Q+7];if(Y===void 0||$===void 0)I(Q,this.length-8);const J=(Y<<24)+this[++Q]*65536+this[++Q]*256+this[++Q];return(BigInt(J)<<BigInt(32))+BigInt(this[++Q]*16777216+this[++Q]*65536+this[++Q]*256+$)});M.prototype.readFloatLE=function Z(Q,Y){if(Q=Q>>>0,!Y)X(Q,4,this.length);return x.read(this,Q,!0,23,4)};M.prototype.readFloatBE=function Z(Q,Y){if(Q=Q>>>0,!Y)X(Q,4,this.length);return x.read(this,Q,!1,23,4)};M.prototype.readDoubleLE=function Z(Q,Y){if(Q=Q>>>0,!Y)X(Q,8,this.length);return x.read(this,Q,!0,52,8)};M.prototype.readDoubleBE=function Z(Q,Y){if(Q=Q>>>0,!Y)X(Q,8,this.length);return x.read(this,Q,!1,52,8)};M.prototype.writeUintLE=M.prototype.writeUIntLE=function Z(Q,Y,$,J){if(Q=+Q,Y=Y>>>0,$=$>>>0,!J){const q=Math.pow(2,8*$)-1;G(this,Q,Y,$,q,0)}let D=1,F=0;this[Y]=Q&255;while(++F<$&&(D*=256))this[Y+F]=Q/D&255;return Y+$};M.prototype.writeUintBE=M.prototype.writeUIntBE=function Z(Q,Y,$,J){if(Q=+Q,Y=Y>>>0,$=$>>>0,!J){const q=Math.pow(2,8*$)-1;G(this,Q,Y,$,q,0)}let D=$-1,F=1;this[Y+D]=Q&255;while(--D>=0&&(F*=256))this[Y+D]=Q/F&255;return Y+$};M.prototype.writeUint8=M.prototype.writeUInt8=function Z(Q,Y,$){if(Q=+Q,Y=Y>>>0,!$)G(this,Q,Y,1,255,0);return this[Y]=Q&255,Y+1};M.prototype.writeUint16LE=M.prototype.writeUInt16LE=function Z(Q,Y,$){if(Q=+Q,Y=Y>>>0,!$)G(this,Q,Y,2,65535,0);return this[Y]=Q&255,this[Y+1]=Q>>>8,Y+2};M.prototype.writeUint16BE=M.prototype.writeUInt16BE=function Z(Q,Y,$){if(Q=+Q,Y=Y>>>0,!$)G(this,Q,Y,2,65535,0);return this[Y]=Q>>>8,this[Y+1]=Q&255,Y+2};M.prototype.writeUint32LE=M.prototype.writeUInt32LE=function Z(Q,Y,$){if(Q=+Q,Y=Y>>>0,!$)G(this,Q,Y,4,4294967295,0);return this[Y+3]=Q>>>24,this[Y+2]=Q>>>16,this[Y+1]=Q>>>8,this[Y]=Q&255,Y+4};M.prototype.writeUint32BE=M.prototype.writeUInt32BE=function Z(Q,Y,$){if(Q=+Q,Y=Y>>>0,!$)G(this,Q,Y,4,4294967295,0);return this[Y]=Q>>>24,this[Y+1]=Q>>>16,this[Y+2]=Q>>>8,this[Y+3]=Q&255,Y+4};M.prototype.writeBigUInt64LE=N(function Z(Q,Y=0){return D1(this,Q,Y,BigInt(0),BigInt("0xffffffffffffffff"))});M.prototype.writeBigUInt64BE=N(function Z(Q,Y=0){return F1(this,Q,Y,BigInt(0),BigInt("0xffffffffffffffff"))});M.prototype.writeIntLE=function Z(Q,Y,$,J){if(Q=+Q,Y=Y>>>0,!J){const K=Math.pow(2,8*$-1);G(this,Q,Y,$,K-1,-K)}let D=0,F=1,q=0;this[Y]=Q&255;while(++D<$&&(F*=256)){if(Q<0&&q===0&&this[Y+D-1]!==0)q=1;this[Y+D]=(Q/F>>0)-q&255}return Y+$};M.prototype.writeIntBE=function Z(Q,Y,$,J){if(Q=+Q,Y=Y>>>0,!J){const K=Math.pow(2,8*$-1);G(this,Q,Y,$,K-1,-K)}let D=$-1,F=1,q=0;this[Y+D]=Q&255;while(--D>=0&&(F*=256)){if(Q<0&&q===0&&this[Y+D+1]!==0)q=1;this[Y+D]=(Q/F>>0)-q&255}return Y+$};M.prototype.writeInt8=function Z(Q,Y,$){if(Q=+Q,Y=Y>>>0,!$)G(this,Q,Y,1,127,-128);if(Q<0)Q=255+Q+1;return this[Y]=Q&255,Y+1};M.prototype.writeInt16LE=function Z(Q,Y,$){if(Q=+Q,Y=Y>>>0,!$)G(this,Q,Y,2,32767,-32768);return this[Y]=Q&255,this[Y+1]=Q>>>8,Y+2};M.prototype.writeInt16BE=function Z(Q,Y,$){if(Q=+Q,Y=Y>>>0,!$)G(this,Q,Y,2,32767,-32768);return this[Y]=Q>>>8,this[Y+1]=Q&255,Y+2};M.prototype.writeInt32LE=function Z(Q,Y,$){if(Q=+Q,Y=Y>>>0,!$)G(this,Q,Y,4,2147483647,-2147483648);return this[Y]=Q&255,this[Y+1]=Q>>>8,this[Y+2]=Q>>>16,this[Y+3]=Q>>>24,Y+4};M.prototype.writeInt32BE=function Z(Q,Y,$){if(Q=+Q,Y=Y>>>0,!$)G(this,Q,Y,4,2147483647,-2147483648);if(Q<0)Q=4294967295+Q+1;return this[Y]=Q>>>24,this[Y+1]=Q>>>16,this[Y+2]=Q>>>8,this[Y+3]=Q&255,Y+4};M.prototype.writeBigInt64LE=N(function Z(Q,Y=0){return D1(this,Q,Y,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});M.prototype.writeBigInt64BE=N(function Z(Q,Y=0){return F1(this,Q,Y,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});M.prototype.writeFloatLE=function Z(Q,Y,$){return q1(this,Q,Y,!0,$)};M.prototype.writeFloatBE=function Z(Q,Y,$){return q1(this,Q,Y,!1,$)};M.prototype.writeDoubleLE=function Z(Q,Y,$){return K1(this,Q,Y,!0,$)};M.prototype.writeDoubleBE=function Z(Q,Y,$){return K1(this,Q,Y,!1,$)};M.prototype.copy=function Z(Q,Y,$,J){if(!M.isBuffer(Q))throw new TypeError("argument should be a Buffer");if(!$)$=0;if(!J&&J!==0)J=this.length;if(Y>=Q.length)Y=Q.length;if(!Y)Y=0;if(J>0&&J<$)J=$;if(J===$)return 0;if(Q.length===0||this.length===0)return 0;if(Y<0)throw new RangeError("targetStart out of bounds");if($<0||$>=this.length)throw new RangeError("Index out of range");if(J<0)throw new RangeError("sourceEnd out of bounds");if(J>this.length)J=this.length;if(Q.length-Y<J-$)J=Q.length-Y+$;const D=J-$;if(this===Q&&typeof Uint8Array.prototype.copyWithin==="function")this.copyWithin(Y,$,J);else Uint8Array.prototype.set.call(Q,this.subarray($,J),Y);return D};M.prototype.fill=function Z(Q,Y,$,J){if(typeof Q==="string"){if(typeof Y==="string")J=Y,Y=0,$=this.length;else if(typeof $==="string")J=$,$=this.length;if(J!==void 0&&typeof J!=="string")throw new TypeError("encoding must be a string");if(typeof J==="string"&&!M.isEncoding(J))throw new TypeError("Unknown encoding: "+J);if(Q.length===1){const F=Q.charCodeAt(0);if(J==="utf8"&&F<128||J==="latin1")Q=F}}else if(typeof Q==="number")Q=Q&255;else if(typeof Q==="boolean")Q=Number(Q);if(Y<0||this.length<Y||this.length<$)throw new RangeError("Out of range index");if($<=Y)return this;if(Y=Y>>>0,$=$===void 0?this.length:$>>>0,!Q)Q=0;let D;if(typeof Q==="number")for(D=Y;D<$;++D)this[D]=Q;else{const F=M.isBuffer(Q)?Q:M.from(Q,J),q=F.length;if(q===0)throw new TypeError('The value "'+Q+'" is invalid for argument "value"');for(D=0;D<$-Y;++D)this[D+Y]=F[D%q]}return this};var E={};b("ERR_BUFFER_OUT_OF_BOUNDS",function(Z){if(Z)return`${Z} is outside of buffer bounds`;return"Attempt to access memory outside buffer bounds"},RangeError);b("ERR_INVALID_ARG_TYPE",function(Z,Q){return`The "${Z}" argument must be of type number. Received type ${typeof Q}`},TypeError);b("ERR_OUT_OF_RANGE",function(Z,Q,Y){let $=`The value of "${Z}" is out of range.`,J=Y;if(Number.isInteger(Y)&&Math.abs(Y)>4294967296)J=e(String(Y));else if(typeof Y==="bigint"){if(J=String(Y),Y>BigInt(2)**BigInt(32)||Y<-(BigInt(2)**BigInt(32)))J=e(J);J+="n"}return $+=` It must be ${Q}. Received ${J}`,$},RangeError);var o1=/[^+/0-9A-Za-z-_]/g,t1=function(){const Q=new Array(256);for(let Y=0;Y<16;++Y){const $=Y*16;for(let J=0;J<16;++J)Q[$+J]="0123456789abcdef"[Y]+"0123456789abcdef"[J]}return Q}();var Q2=new TextEncoder,Y2=new TextDecoder,k=self,Z2=async(Z)=>{const Q=await k.wasm._ralloc(Z.byteLength);return new Uint8Array(k.wasm.wasmMemory.buffer).set(Z,Q),Q},X1=async(Z)=>{const Q=Q2.encode(Z),Y=await Z2(Q);return[Q.byteLength,Y]},l=(Z)=>{const Q=u(Z);if(Q?.buf.length==0)return{buf:void 0,ok:Q.ok};return{buf:Y2.decode(Q.buf),ok:Q.ok}},u=(Z)=>{const Q=new Uint8Array(k.wasm.wasmMemory.buffer),Y=Buffer.from(Q.slice(Z,Z+9)),$=Y.readUint32LE(0),J=Y.readUInt32LE(4),D=Y.readUint8(8)!=1,F=Q.slice(J,J+$);return k.wasm._rfree(J,$),k.wasm._rfree(Z,9),{buf:F,ok:D}};self.Buffer=g;self.ptr2str=l;self.ptr2bytes=u;self.str2ptr=X1;var A={},G1=0;Object.assign(Module,{emscriptenhttpconnect:function(Z,Q,Y,$){if(!Y)Y="GET";const J=(U)=>{self.wasm={wasmMemory:Module.HEAPU8,_rfree:Module._rfree,_ralloc:Module._ralloc};const W=Module._get_store(U);return l(W)?.buf},D=J(1),F=J(2),q=J(3)||"git",K=J(4),R=new XMLHttpRequest;if(R.open(Y,D&&D!=="null"?D+Z.replace(/https?:\/\//,`/${q}:\$token\$@`):Z,!1),R.responseType="arraybuffer",R.setRequestHeader("x-private-token",F),K)R.setRequestHeader("x-protocol",K);if($)Object.keys($).forEach((U)=>R.setRequestHeader(U,$[U]));if(A[G1]={xhr:R,resultbufferpointer:0,buffersize:Q},Y==="GET")R.send();return G1++},emscriptenhttpwrite:function(Z,Q,Y){const $=A[Z],J=new Uint8Array(Module.HEAPU8.buffer,Q,Y).slice(0);if(!$.content)$.content=J;else{const D=new Uint8Array($.content.length+J.length);D.set($.content),D.set(J,$.content.length),$.content=D}},emscriptenhttpread:function(Z,Q,Y){const $=A[Z];if($.content)$.xhr.send($.content.buffer),$.content=null;let J=$.xhr.response.byteLength-$.resultbufferpointer;if(J>Y)J=Y;const D=new Uint8Array($.xhr.response,$.resultbufferpointer,J);return writeArrayToMemory(D,Q),$.resultbufferpointer+=J,J},emscriptenhttpfree:function(Z){delete A[Z]}});
