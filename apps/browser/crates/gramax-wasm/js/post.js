var R=new TextEncoder,C=new TextDecoder,B=self,P=async(w)=>{let m=await B.wasm._ralloc(w.byteLength);return new Uint8Array(B.wasm.wasmMemory.buffer).set(w,m),m},K=async(w)=>{let m=R.encode(w),_=await P(m);return[m.byteLength,_]},O=(w)=>{let m=Q(w);if(m?.buf.length==0)return{buf:void 0,ok:m.ok};return{buf:C.decode(m.buf),ok:m.ok}},Q=(w)=>{let m=new Uint8Array(B.wasm.wasmMemory.buffer),_=new DataView(m.buffer,w,9),U=_.getUint32(0,!0),V=_.getUint32(4,!0),M=_.getUint8(8)!==1,A=m.slice(V,V+U);return B.wasm._rfree(V,U),B.wasm._rfree(w,9),{buf:A,ok:M}};self.ptr2str=O;self.ptr2bytes=Q;self.str2ptr=K;self.emscriptenhttpconnections={};var E=new BroadcastChannel("pthreads-broadcast"),L=async(w,m)=>{let _=Module._set_last_http_error,[U,V]=await K(m);await _(w,V,U)},g=new TextDecoder,G=async(w,m,_)=>{if(w>=200&&w<300)return;try{if(m.length>4096)m=m.slice(0,4096);let U=g.decode(m);if(w===0&&U===""){w=999;let V=_?new URL(_).hostname:"";U=`Failed to send request to '${_}': domain '${V}' unreachable or CORS headers incorrect`}await L(w,U)}catch(U){console.error("failed to set last http error",U)}};E.addEventListener("message",(w)=>{if(w.data.type==="cancel"){if(self.cancelToken===w.data.id&&Date.now()-w.data.date<1000)Object.values(self.emscriptenhttpconnections).forEach((m)=>{m?.abortController?.abort()})}});var J=(w)=>{self.wasm={wasmMemory:Module.HEAPU8,_rfree:Module._rfree,_ralloc:Module._ralloc};let m=Module._get_store(w);return O(m)?.buf};Object.assign(Module,{emscriptenhttpconnect:async function(w,m,_,U){return new Promise((M)=>{let A=Date.now()>>10;if(!_)_="GET";let j=J(1),k=J(2),F=J(3)||"git",T=J(4),D=new XMLHttpRequest,W=new AbortController;if(w=j&&j!=="null"?j+w.replace(/https?:\/\//,"/"):w,D.open(_,w,!0),D.responseType="arraybuffer",D.withCredentials=!0,k)D.setRequestHeader("x-private-token",k);if(F)D.setRequestHeader("x-git-username",F);if(T)D.setRequestHeader("x-protocol",T);if(self.emscriptenhttpconnections[A]={xhr:D,abortController:W,resultbufferpointer:0,buffersize:m},U)Object.keys(U).forEach((q)=>D.setRequestHeader(q,U[q]));let X=Date.now(),Y=0,Z=0;if(D.onprogress=(q)=>{let $=Date.now();if($-X>1000)Y=q.loaded-Z,Z=q.loaded,X=$,self.postMessage({type:"remote-progress",progress:{type:"download",data:{id:self.cancelToken,bytes:q.loaded,downloadSpeedBytes:Y}}})},W.signal.addEventListener("abort",()=>{D.abort()}),_==="GET")D.onload=async function(q){await G(D.status,D.response),M(A)},D.onerror=async function(q){await G(D.status,D.response,w),M(A)},D.onabort=function(){M(A)},D.send();else M(A)})},emscriptenhttpwrite:function(w,m,_){let U=self.emscriptenhttpconnections[w],V=new Uint8Array(Module.HEAPU8.buffer,m,_).slice(0);if(!U.content)U.content=V;else{let M=new Uint8Array(U.content.length+V.length);M.set(U.content),M.set(V,U.content.length),U.content=M}},emscriptenhttpread:function(w,m,_){function U(M,A){let j=self.emscriptenhttpconnections[w],k=j.xhr.response.byteLength-j.resultbufferpointer;if(k>A)k=A;let F=new Uint8Array(j.xhr.response,j.resultbufferpointer,k);return writeArrayToMemory(F,M),j.resultbufferpointer+=k,k}return new Promise((M)=>{let A=self.emscriptenhttpconnections[w];if(A.content)A.xhr.onload=async function(j){await G(A.xhr.status,A.xhr.response),M(U(m,_))},A.xhr.onabort=function(){M(-999)},A.xhr.onerror=function(j){G(A.xhr.status,A.xhr.response),M(-1)},A.xhr.send(A.content.buffer),A.content=null;else M(U(m,_))})},emscriptenhttpfree:function(w){delete self.emscriptenhttpconnections[w]}});
